# パフォーマンスガイドライン

## データベース

- **クエリの最適化**
  - 同一テーブルへのアクセスは可能な限り1回のクエリにまとめる
  - N+1問題を避ける
  - ネットワークラウンドトリップを最小化する

- **統合のテクニック例**:
  - 複数の集計: `COUNT(*) FILTER (WHERE ...)` や `SUM(CASE WHEN ... END)` で1クエリ化
  - 条件付き更新: `CASE` 式で複数UPDATEを1クエリ化
  - 関連データの取得: JOINやサブクエリで1クエリ化

- **インデックス**
  - WHERE句、JOIN条件、ORDER BY句で使用するカラムにはインデックスを検討
  - カーディナリティが低いカラム（boolean等）への単独インデックスは避ける
  - 複合インデックスはカラム順序に注意（選択性の高い順）

- **バッチ処理**
  - 大量INSERT/UPDATEはバルク操作を使用（1件ずつループしない）
  - 大量データ処理はページネーションまたはカーソルで分割

- **クエリ設計**
  - SELECT * を避け、必要なカラムのみ取得
  - EXISTSはCOUNT(*)より効率的（存在確認の場合）
  - OFFSET/LIMITの深いページングはカーソルベースに変更を検討

## キャッシュ

- **キャッシュすべきデータ**
  - 頻繁に読み取られ、変更が少ないデータ
  - 計算コストの高い結果
  - 外部API呼び出しの結果

- **キャッシュ無効化**
  - TTLベースと明示的無効化を適切に使い分け
  - キャッシュキーの命名規則を統一（例: `user:{id}:profile`）

## API設計

- **リクエスト最適化**
  - 独立したAPIコールは並列実行（Promise.all等）
  - 必要なデータのみリクエスト（GraphQLのfragment、REST APIのfields指定）

- **レスポンス最適化**
  - 大量データはページネーション必須
  - 不要なネストや冗長なデータを避ける

## リソース管理

- **ストリーム処理**
  - 大きなファイルはストリームで処理（全体をメモリに読み込まない）
  - 大量データのJSONはストリームパーサーを検討

- **コネクション管理**
  - DBコネクションプールを適切に設定
  - 外部サービスへの接続はタイムアウトを設定
